<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Time Master Duel (Online)</title>
    <!-- Loads Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- USING OLDER, MORE STABLE FIREBASE (v7.1.0) -->
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.1.0/firebase-firestore.js"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }
        .btn-base {
            padding: 0.75rem 1rem;
            font-size: 1rem; 
            font-weight: 700;
            transition: all 0.2s;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .btn-start { background-color: #10b981; color: white; }
        .btn-p1 { background-color: #ef4444; color: white; box-shadow: 0 8px 10px rgba(239, 68, 68, 0.4); }
        .btn-p2 { background-color: #3b82f6; color: white; box-shadow: 0 8px 10px rgba(59, 130, 246, 0.4); }
        .btn-base:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15); }
        .btn-base:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; }
        .input-code {
            padding: 0.75rem;
            border: 2px solid #ccc;
            border-radius: 0.5rem;
            text-transform: uppercase;
            text-align: center;
            font-size: 1.25rem;
            font-weight: bold;
        }
        .hidden { display: none; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-start min-h-screen p-4">

    <div id="app-container" class="w-full max-w-lg bg-white p-4 md:p-6 rounded-xl shadow-2xl text-center mx-auto mt-4 mb-4">
        
        <!-- Autentiseringsstatus -->
        <p id="auth-status" class="text-xs text-gray-500 mb-4 break-all">Initializing...</p>

        <!-- Initial Huvudrubrik -->
        <h1 id="app-title" class="text-2xl font-extrabold text-gray-900 mb-2">Time Master: Duel (Online)</h1>
        <p id="app-description" class="text-sm text-gray-600 mb-4">Compete against friends over the internet. Best of 3 rounds!</p>

        <!-- --- SPELKONTROLL (SETUP) --- -->
        <div id="game-control-area" class="space-y-4 p-4 rounded-xl bg-gray-50 border hidden">
            <h2 class="text-xl font-bold text-gray-800">Create or Join</h2>
            
            <button id="start-button" class="btn-base btn-start w-full" disabled>
                Start New Game (Player 1)
            </button>

            <!-- BORTTAGET: Fält för manuell kodinmatning -->
            
            <!-- NY SEKTION FÖR TILLGÄNGLIGA SPEL -->
            <div id="available-games-area" class="text-left">
                <h3 class="text-sm font-bold text-gray-700 mb-2">Active Games to Join:</h3>
                <div id="available-games-list" class="space-y-2">
                    <!-- Spelknappar renderas här -->
                    <p class="text-xs text-gray-400">Fetching...</p>
                </div>
            </div>
            <!-- SLUT NY SEKTION -->
        </div>

        <!-- --- HUVUD SPELYTA (GAME) --- -->
        <div id="main-game-area" class="hidden">
            
            <p id="game-code-display" class="text-sm font-semibold text-indigo-700 mb-2">No active match</p>
            
            <!-- Omgångsräknare & Måltid Display -->
            <div class="mb-4 p-4 bg-indigo-50 rounded-lg shadow-inner">
                <p id="round-counter" class="text-sm font-semibold text-indigo-700 mb-1">Round -- of 3</p>
                <h2 id="target-display" class="text-base font-semibold text-indigo-700">Waiting for connection...</h2>
                <p id="target-time" class="text-3xl font-mono text-indigo-900 mt-1">--</p>
            </div>

            <p id="waiting-for-player" class="text-lg font-bold text-red-600 mb-4 hidden">Waiting for opponents...</p>

            <!-- Poängtavla -->
            <div id="scoreboard-area" class="mb-4 p-3 rounded-xl shadow-lg border-2 border-gray-300 bg-gray-50">
                <h3 class="text-lg font-bold mb-2 text-gray-700">Total Error Margin (Lowest is Best)</h3>
                <!-- Resultat visas här i stället för hårkodade P1/P2 -->
                <div id="total-scoreboard" class="flex flex-col gap-2 text-sm text-gray-700">
                    <p class="text-center text-xs text-gray-500">Results shown after match finish.</p>
                </div>
            </div>

            <!-- Resultat Display (Per Omgång) -->
            <div id="result-area" class="mb-4 p-3 rounded-xl shadow-lg border-2 hidden">
                <h3 class="text-xl font-bold mb-3 text-gray-800">Round Result</h3>

                <div id="round-results-display" class="flex flex-wrap gap-3 justify-center">
                    <!-- Spelresultat renderas här -->
                </div>

                <p id="round-winner-status" class="text-lg font-extrabold mt-3 p-2 rounded-lg bg-yellow-100 text-yellow-800"></p>
            </div>

            <!-- Slutresultat -->
            <div id="final-result-area" class="p-4 rounded-xl shadow-2xl hidden bg-purple-100 border-4 border-purple-500">
                <h3 class="text-2xl font-extrabold text-purple-800 mb-2">TOTAL WINNER! 🎉</h3>
                <p id="final-winner-status" class="text-xl font-bold text-gray-800 mb-2"></p>
            </div>

            <!-- Interaktionsknappar -->
            <div class="space-y-3 mt-4">
                <div class="flex gap-3">
                    <!-- FIX: Visa en universell knapp för den egna spelaren -->
                    <button id="multi-wait-button" class="btn-base btn-p2 w-full" disabled> Click NOW! </button>
                </div>
                <!-- FIX: Nytt ID för att separera från SETUP-knappen i den första kontrollen -->
                <button id="start-next-round-button" class="btn-base btn-start w-full"> START ROUND </button>
            </div>
            
            <button onclick="resetLocalState()" class="text-xs text-gray-500 mt-4 underline">Leave Match/Reset</button>
        </div>

    </div>

    <script>
        
        // --- GLOBAL VARIABLES (CORRECTED FOR ONLINE HOSTING) ---
        const appId = 'GITHUB_DUEL_ID';
        
        // ***********************************************************************************
        // !!! IMPORTANT: PASTE YOUR PERSONAL firebaseConfig HERE !!!
        // ***********************************************************************************
        const firebaseConfig = {
    apiKey: "AIzaSyAmsrwDhNmVZsmYmnGEmA9c7nznBTj1G7M",
    authDomain: "tidsduellen.firebaseapp.com",
    projectId: "tidsduellen",
    storageBucket: "tidsduellen.firebasestorage.app",
    messagingSenderId: "397732128249",
    appId: "1:397732128249:web:f27ddc610c300b4b504928",
    measurementId: "G-THJVN8S9EN"
    };
            const initialAuthToken = null; 
            
            // Simulates a unique ID to bypass the API key requirement.
            // Uses localStorage to save a constant ID per user/browser
            const storedUserId = localStorage.getItem('multiUserId');
            const simulatedUserId = storedUserId || crypto.randomUUID();
            if (!storedUserId) localStorage.setItem('multiUserId', simulatedUserId);


            let app, db, auth;
            let userId = simulatedUserId; // Use the saved/generated ID
            let gameId = null;
            let playerRole = null; // Not strictly necessary with multiple players, but kept for some UI controls
            let playerIndex = -1; // The player's index in the playerIds array

            // Global element references
            let authStatus;
            let gameControlArea;
            let startSetupButton;
            let startNextRoundButton;
            let gameCodeDisplay;
            let waitingForPlayer;
            let roundCounter;
            let targetDisplay;
            let targetTimeText;
            let multiWaitButton;
            let resultArea;
            let roundWinnerStatus;
            let totalScoreboard;
            let roundResultsDisplay;
            let availableGamesList;
            let mainGameArea;

            // Per-round result elements (not needed anymore, rendered dynamically)
            
            // Game constants
            const MS_TO_S = 1000;
            const maxRounds = 3; 

            // --- HELPER FUNCTIONS ---
            
            function initializeAppComponents() {
                // This function runs AFTER DOMContentLoaded and GUARANTEES that all elements exist.
                authStatus = document.getElementById('auth-status');
                gameControlArea = document.getElementById('game-control-area');
                startSetupButton = document.getElementById('start-button'); // Button in SETUP mode
                startNextRoundButton = document.getElementById('start-next-round-button'); // Button in GAME mode
                gameCodeDisplay = document.getElementById('game-code-display');
                waitingForPlayer = document.getElementById('waiting-for-player');
                roundCounter = document.getElementById('round-counter');
                targetDisplay = document.getElementById('target-display');
                targetTimeText = document.getElementById('target-time');
                multiWaitButton = document.getElementById('multi-wait-button'); // Universal click button
                resultArea = document.getElementById('result-area');
                roundWinnerStatus = document.getElementById('round-winner-status');
                totalScoreboard = document.getElementById('total-scoreboard'); // New: For total scoreboard
                roundResultsDisplay = document.getElementById('round-results-display'); // New: For results per round
                availableGamesList = document.getElementById('available-games-list'); // Reference for the list
                mainGameArea = document.getElementById('main-game-area'); // Must be defined globally

                // Add Event Listeners (now that elements are defined)
                startSetupButton.addEventListener('click', async () => {
                    if (!gameId) { 
                        await createNewGame();
                    } else {
                        alert("A game is already started. Please leave the match first.");
                    }
                });

                startNextRoundButton.addEventListener('click', async () => {
                    let gameData = null;
                    if (!gameId) return; 

                    const gameDoc = await getGameRef().get();
                    if (gameDoc.exists) {
                        gameData = gameDoc.data();
                    }

                    if (gameData && gameData.playerIds[0] === userId && (gameData.status === 'ROUND_FINISHED' || gameData.status === 'MATCH_FINISHED' || gameData.status === 'SETUP')) {
                        await startNextRoundOrMatch(gameData);
                    }
                });

                multiWaitButton.addEventListener('click', async () => {
                    if (playerIndex === -1) return;

                    const gameDoc = await getGameRef().get();
                    if (!gameDoc.exists) return;

                    const gameData = gameDoc.data();
                    
                    if (gameData.status !== 'WAITING_FOR_CLICKS') return;

                    const localStartTime = parseFloat(sessionStorage.getItem('gameStartTime') || 0);
                    if (localStartTime === 0) {
                        alert("Error: Local start time is missing. Please try restarting the round.");
                        return;
                    }
                    
                    const finalElapsedTime = performance.now() - localStartTime;

                    multiWaitButton.textContent = 'Clicked...';
                    multiWaitButton.disabled = true;

                    await recordClickTime(gameData, finalElapsedTime);
                });
                
                document.querySelector('button[onclick="resetLocalState()"]').addEventListener('click', resetLocalState);
                
                // --- Call Firebase initialization ---
                initApp();
            }

            // --- FIREBASE INITIALIZATION AND SIMULATED AUTHENTICATION ---

            function getGameRef(id = gameId) {
                if (!db || !db.collection) {
                    throw new Error("Firestore instance (db) is not initialized.");
                }
                // Saves in the root level 'games/{gameId}'
                return db.collection('games').doc(id); 
            }
            
            function getGamesCollection() {
                if (!db || !db.collection) {
                    throw new Error("Firestore instance (db) is not initialized.");
                }
                // Fetches all games in the root level
                return db.collection('games');
            }

            // CORRECTED: Generates a 3-digit code (000-999)
            function generateGameCode() {
                return String(Math.floor(Math.random() * 1000)).padStart(3, '0');
            }

            async function initFirebase() {
                try {
                    // FIX: Add control to prevent double initialization
                    if (firebase.apps.length > 0) {
                        console.warn("Firebase already initialized. Skipping.");
                        // Set UI to start mode again if it is already running
                        resetLocalState(); 
                        return;
                    }

                    if (typeof firebase === 'undefined' || !firebase.initializeApp) {
                        throw new Error("Firebase library not defined globally. Check network access to CDN or if script loading failed.");
                    }

                    // USING V7 SYNTAX FOR INITIALIZATION
                    app = firebase.initializeApp(firebaseConfig);
                    db = firebase.firestore();
                    firebase.firestore.setLogLevel('debug'); 

                    // --- SIMULATED LOGIN ---
                    authStatus.textContent = `Your User ID: ${userId.substring(0, 8)}...`;
                    
                    // FIX: Call resetLocalState immediately after initialization to force UI display
                    resetLocalState();
                    
                    // --- END SIMULATED LOGIN ---

                } catch (error) {
                    console.error("Firebase Initialization Error:", error);
                    // Extra instruction on switching configuration if it fails.
                    authStatus.textContent = `CRITICAL ERROR: Connection error. Did you paste your PERSONAL firebaseConfig? (${error.message || 'Unknown error'})`;
                }
            }
            
            function initApp() {
                // Check if Firebase has loaded before initializing
                if (typeof firebase !== 'undefined' && firebase.initializeApp) {
                    initFirebase();
                } else {
                    document.getElementById('auth-status').textContent = 'CRITICAL ERROR: Firebase libraries could not be loaded. Check network access to CDNs.';
                    console.error("Firebase library not defined after aggressive check.");
                }
            }

            // --- NEW: FUNCTION TO LISTEN FOR AVAILABLE GAMES ---

            let unsubscribeAvailableGames = null;

            function listenForAvailableGames() {
                if (unsubscribeAvailableGames) unsubscribeAvailableGames();

                // Fetches games in SETUP status that the user is not part of
                const gamesRef = getGamesCollection().where('status', '==', 'SETUP');
                
                unsubscribeAvailableGames = gamesRef.onSnapshot((snapshot) => {
                    renderAvailableGames(snapshot.docs);
                }, (error) => {
                    console.error("Error fetching available games:", error);
                });
            }

            function renderAvailableGames(gameDocs) {
                let html = '';
                let gamesFound = 0;

                gameDocs.forEach(doc => {
                    const data = doc.data();
                    
                    // Filter out games you are already in
                    if (data.playerIds && data.playerIds.includes(userId)) return;

                    const playerCount = data.playerIds ? data.playerIds.length : 0;

                    html += `
                        <button onclick="joinExistingGame('${data.gameCode}')" 
                            class="btn-base btn-p2 w-full text-sm py-2 px-3 justify-between flex items-center bg-blue-100 hover:bg-blue-200 text-blue-800 border border-blue-400">
                            <span>Game Code: <strong>${data.gameCode}</strong></span>
                            <span>Players: ${playerCount} joined</span>
                        </button>
                    `;
                    gamesFound++;
                });

                if (gamesFound === 0) {
                    html = '<p class="text-xs text-gray-400">No active games found. Start a new one!</p>';
                }
                
                availableGamesList.innerHTML = html;
            }


            // --- GAME HANDLER AND DATABASE FUNCTIONS ---

            /** Generates a random time between 5.00 and 30.00 seconds (in milliseconds). */
            function generateRandomTime() {
                const minMs = 5000;
                const maxMs = 30000;
                return Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
            }

            /** Formats a deviation. */
            function formatDeviation(deviationMs, element) {
                const deviationSecondsAbsolute = Math.abs(deviationMs / MS_TO_S).toFixed(2);
                const deviationSign = deviationMs >= 0 ? '+' : '-';
                
                // Clear old colors
                element.classList.remove('text-red-600', 'text-yellow-600', 'text-green-600'); 

                if (Math.abs(deviationMs) < 100) { // < 0.10s is perfect
                    element.classList.add('text-green-600');
                } else if (deviationMs < 0) {
                    // Too early
                    element.classList.add('text-yellow-600'); 
                } else {
                    // Too late
                    element.classList.add('text-red-600'); 
                }

                return `${deviationSign}${deviationSecondsAbsolute} s`;
            }

            /** Updates the UI based on player role and game status. */
            function updateUI(gameData) {
                // Hide SETUP view and show GAME view
                gameControlArea.classList.add('hidden');
                mainGameArea.classList.remove('hidden');
                
                // Handle title visibility
                if (gameData.round > 1 || gameData.status === 'MATCH_FINISHED') {
                    document.getElementById('app-title').classList.add('hidden');
                    document.getElementById('app-description').classList.add('hidden');
                } else {
                    document.getElementById('app-title').classList.remove('hidden');
                    document.getElementById('app-description').classList.remove('hidden');
                }

                // Round counter
                roundCounter.textContent = `Round ${gameData.round} of ${maxRounds}`;
                gameCodeDisplay.textContent = `Game Code: ${gameData.gameCode}`;


                // --- Handle Game Status ---
                
                // Result and final status
                resultArea.classList.add('hidden');
                finalResultArea.classList.add('hidden');
                
                // Default button states
                multiWaitButton.disabled = true;
                startNextRoundButton.disabled = true; 

                if (gameData.status === 'SETUP') {
                    targetDisplay.textContent = 'Waiting for opponents...';
                    targetTimeText.textContent = `Code: ${gameData.gameCode}`;
                    waitingForPlayer.classList.remove('hidden');

                    if (gameData.playerIds[0] === userId) {
                        // FIX: Allow solo start immediately
                        startNextRoundButton.textContent = `START ROUND 1 of ${maxRounds}`;
                        startNextRoundButton.disabled = false; 
                    } else {
                         startNextRoundButton.textContent = `Waiting for creator to start...`;
                         startNextRoundButton.disabled = true;
                    }
                    
                    // Update player list in setup
                    totalScoreboard.innerHTML = `<p class="font-bold">Players Joined: ${gameData.playerIds.length}</p>`;
                    totalScoreboard.classList.remove('hidden');
                    
                } else if (gameData.status === 'WAITING_FOR_CLICKS') {
                    waitingForPlayer.classList.add('hidden');
                    targetDisplay.textContent = 'Close your eyes and count! 🧠';
                    targetTimeText.textContent = `${(gameData.targetTimeMs / MS_TO_S).toFixed(2)} s`; 

                    const clickIndex = gameData.playerIds.indexOf(userId);
                    
                    multiWaitButton.style.display = 'block'; 
                    
                    if (clickIndex !== -1) {
                        if (gameData.clickTimes[clickIndex] === 0) {
                            multiWaitButton.disabled = false;
                            multiWaitButton.textContent = 'Click NOW!';
                        } else {
                            multiWaitButton.textContent = 'Clicked!';
                        }
                    } else {
                        // If the player is watching but not in the game
                        multiWaitButton.style.display = 'none';
                    }

                } else if (gameData.status === 'ROUND_FINISHED') {
                    waitingForPlayer.classList.add('hidden');
                    targetDisplay.textContent = 'Round Finished!';
                    targetTimeText.textContent = 'See Results!';

                    // Show result details
                    displayResultDetails(gameData);
                    displayScoreboard(gameData);

                    // Handle next round. Only the creator (PlayerIds[0]) starts.
                    if (gameData.playerIds[0] === userId) {
                        const nextRound = gameData.round + 1;
                        startNextRoundButton.disabled = false; // ACTIVATE BUTTON

                        if (nextRound > maxRounds) {
                            startNextRoundButton.textContent = 'PLAY AGAIN (Reset)';
                        } else {
                            // FIX: Clear text for the next round
                            startNextRoundButton.textContent = `START NEXT ROUND (${nextRound} of ${maxRounds})`; 
                        }
                    } else {
                        startNextRoundButton.textContent = `Waiting for creator to start next round...`;
                        startNextRoundButton.disabled = true;
                    }

                } else if (gameData.status === 'MATCH_FINISHED') {
                    waitingForPlayer.classList.add('hidden');
                    targetDisplay.textContent = `Match Finished!`;
                    targetTimeText.textContent = 'Play Again!';

                    // Show final result
                    displayFinalWinner(gameData);
                    displayScoreboard(gameData); // Show final scoreboard

                    // Only the creator starts over
                    if (gameData.playerIds[0] === userId) {
                        startNextRoundButton.textContent = 'PLAY AGAIN (Reset)';
                        startNextRoundButton.disabled = false; // ACTIVATE BUTTON
                    } else {
                        startNextRoundButton.textContent = 'Waiting for creator to start new match...';
                        startNextRoundButton.disabled = true;
                    }
                }
            }

            /** Shows the detailed result for the round. */
            function displayResultDetails(gameData) {
                const targetTimeMs = gameData.targetTimeMs;
                roundResultsDisplay.innerHTML = ''; // Clear old results
                let closestDeviation = Infinity;
                let closestPlayerIndex = -1;

                // 1. Calculate deviations and find winner
                gameData.playerIds.forEach((id, index) => {
                    const clickTimeMs = gameData.clickTimes[index];
                    const devMs = clickTimeMs - targetTimeMs;
                    const absDev = Math.abs(devMs);
                    
                    if (absDev < closestDeviation) {
                        closestDeviation = absDev;
                        closestPlayerIndex = index;
                    }

                    const playerNumber = index + 1;
                    const colorClass = index === 0 ? 'border-red-400 bg-red-50' : (index === 1 ? 'border-blue-400 bg-blue-50' : 'border-gray-400 bg-gray-50');

                    const resultCard = document.createElement('div');
                    resultCard.className = `w-full sm:w-1/3 p-2 rounded-lg border-2 shadow-md ${colorClass}`;
                    
                    resultCard.innerHTML = `
                        <h4 class="font-bold text-lg text-gray-800">Player ${playerNumber}</h4>
                        <p class="text-sm">Time: <strong class="float-right font-mono">${(clickTimeMs / MS_TO_S).toFixed(2)} s</strong></p>
                        <div class="h-px bg-gray-300 my-1"></div>
                        <p class="font-bold">Deviation: <strong class="float-right font-mono text-base ${absDev < 100 ? 'text-green-600' : 'text-red-600'}">${formatDeviation(devMs, resultCard)}</strong></p>
                    `;
                    roundResultsDisplay.appendChild(resultCard);
                });

                // 2. Show winner status
                roundWinnerStatus.textContent = `Player ${closestPlayerIndex + 1} was closest this round!`;
                
                resultArea.classList.remove('hidden'); 
            }

            /** Shows the total scoreboard. */
            function displayScoreboard(gameData) {
                totalScoreboard.innerHTML = ''; // Clear old results
                totalScoreboard.classList.remove('hidden');
                
                let scores = gameData.playerIds.map((id, index) => ({
                    playerNum: index + 1,
                    totalError: gameData.totalErrors[index] || 0
                }));

                // Sort by lowest error (best result)
                scores.sort((a, b) => a.totalError - b.totalError);
                
                let html = '<h3 class="text-lg font-bold mb-2 text-gray-700">Total Error Margin (Lowest is Best)</h3>';

                scores.forEach((score, index) => {
                    const colorClass = index === 0 ? 'bg-yellow-100 border-yellow-400' : 'bg-gray-100 border-gray-300';
                    const playerColor = score.playerNum === 1 ? 'text-red-700' : (score.playerNum === 2 ? 'text-blue-700' : 'text-gray-700');
                    
                    html += `
                        <div class="flex justify-between items-center p-2 rounded-lg border ${colorClass}">
                            <span class="font-bold ${playerColor}">Player ${score.playerNum}</span>
                            <span class="text-xl font-mono">${(score.totalError / MS_TO_S).toFixed(2)} s</span>
                        </div>
                    `;
                });
                totalScoreboard.innerHTML = html;
            }


            /** Shows the final result. */
            function displayFinalWinner(gameData) {
                const scores = gameData.playerIds.map((id, index) => ({
                    playerNum: index + 1,
                    totalError: gameData.totalErrors[index] || 0
                }));
                scores.sort((a, b) => a.totalError - b.totalError);

                let finalWinnerText = '';
                if (scores.length > 0) {
                    if (scores.length > 1 && scores[0].totalError < scores[1].totalError) {
                        finalWinnerText = `PLAYER ${scores[0].playerNum} WINS! (${(scores[0].totalError / MS_TO_S).toFixed(2)}s error)`;
                    } else if (scores.length > 1 && scores[0].totalError === scores[1].totalError) {
                         finalWinnerText = `TIE between top players! Winner: Player ${scores[0].playerNum} (${(scores[0].totalError / MS_TO_S).toFixed(2)}s error)`;
                    } else {
                        finalWinnerText = `PLAYER ${scores[0].playerNum} WINS! (${(scores[0].totalError / MS_TO_S).toFixed(2)}s error)`;
                    }
                } else {
                    finalWinnerText = 'No players found in the results.';
                }

                finalWinnerStatus.textContent = finalWinnerText;
                finalResultArea.classList.remove('hidden');
            }

            // --- REAL-TIME DATASYNC (onSnapshot) ---

            let unsubscribe = null;

            /** Listens to game updates and handles local start time. */
            function listenToGameUpdatesAndStartTime(docId) {
                if (unsubscribe) unsubscribe();
                gameId = docId;
                // Close listener for available games when we are in a game
                if (unsubscribeAvailableGames) unsubscribeAvailableGames();

                const gameRef = getGameRef(docId);
                
                unsubscribe = gameRef.onSnapshot((docSnap) => {
                    // CORRECTION HERE: Use .data() to retrieve the data
                    if (docSnap.exists) { 
                        const gameData = docSnap.data();
                        
                        // Set player index
                        playerIndex = gameData.playerIds.indexOf(userId);
                        playerRole = playerIndex === 0 ? 'P1' : (playerIndex !== -1 ? 'P_OTHER' : null);

                        if (playerIndex === -1 && gameData.status !== 'SETUP') {
                            alert("You are not in this game.");
                            resetLocalState();
                            return;
                        }

                        // START TIME LOGIC: Set the local start time when status becomes WAITING_FOR_CLICKS
                        if (gameData.status === 'WAITING_FOR_CLICKS' && sessionStorage.getItem('gameStartTime') === null) {
                            // Set startTime to the current performance time to measure elapsed time locally
                            sessionStorage.setItem('gameStartTime', performance.now().toString());
                        } else if (gameData.status !== 'WAITING_FOR_CLICKS') {
                            // Clear start time when the round is over
                            sessionStorage.removeItem('gameStartTime');
                        }

                        updateUI(gameData);

                    } else {
                        // Match deleted
                        alert("The game was closed or no longer exists.");
                        resetLocalState();
                    }
                }, (error) => {
                    console.error("Snapshot error:", error);
                    alert("Error connecting to the game.");
                    resetLocalState();
                });
            }

            // --- PLAYER ACTIONS ---

            /** Creates a new game (P1 only). */
            async function createNewGame() {
                // FIX: Clears old listeners and ID
                resetGameId(); 
                
                const newGameCode = generateGameCode();
                const gameRef = getGameRef(newGameCode);

                const initialData = {
                    gameCode: newGameCode, status: 'SETUP', 
                    round: 1, maxRounds: maxRounds,
                    playerIds: [userId], // Only the creator
                    clickTimes: [0],
                    totalErrors: [0], // A total error margin per player
                    targetTimeMs: 0, 
                    lastUpdateTime: firebase.firestore.FieldValue.serverTimestamp(),
                };

                try {
                    await gameRef.set(initialData);
                    listenToGameUpdatesAndStartTime(newGameCode);
                    // Hide the list when a game is created
                    document.getElementById('available-games-area').classList.add('hidden');
                } catch (error) {
                    console.error("Error creating game:", error);
                    alert("Could not start the game.");
                }
            }

            /** Joins an existing game (P2 and onwards). */
            window.joinExistingGame = async function(code) { // Make global for onclick
                // Use code directly if passed from a clicked button
                let finalCode = code;
                
                // If code is missing (should only happen if manual input was used, which is removed)
                if (!finalCode) {
                    alert("Code missing. Please click an active game in the list.");
                    return;
                }

                const gameRef = getGameRef(finalCode);

                try {
                    await db.runTransaction(async (transaction) => {
                        const gameDoc = await transaction.get(gameRef);

                        // CORRECTION HERE: Use .exists on the transaction result
                        if (!gameDoc.exists) throw "Game does not exist.";
                        const data = gameDoc.data();
                        
                        // FIX: Allow connection if status is SETUP
                        if (data.status !== 'SETUP') throw "The round has already started.";
                        if (data.playerIds.includes(userId)) throw "You are already connected to this game.";
                        
                        // Add the new player to the lists
                        const newPlayerIds = [...data.playerIds, userId];
                        const newClickTimes = [...data.clickTimes, 0];
                        const newTotalErrors = [...data.totalErrors, 0];


                        // Update: Add the new player
                        transaction.update(gameRef, {
                            playerIds: newPlayerIds,
                            clickTimes: newClickTimes,
                            totalErrors: newTotalErrors,
                            lastUpdateTime: firebase.firestore.FieldValue.serverTimestamp(),
                        });
                    });
                    
                    // Listen to the game immediately after connecting
                    listenToGameUpdatesAndStartTime(finalCode);
                    document.getElementById('available-games-area').classList.add('hidden');

                } catch (error) {
                    console.error("Error connecting to game:", error);
                    alert(`Could not connect: ${typeof error === 'string' ? error : error.message}`);
                }
            }

            /** Updates click time in the database when a player clicks. */
            async function recordClickTime(gameData, clickTimeMs) {
                const gameRef = getGameRef();
                
                // Find player index
                const playerClickIndex = gameData.playerIds.indexOf(userId);
                if (playerClickIndex === -1) return; 

                // If player already clicked in this round
                if (gameData.clickTimes[playerClickIndex] !== 0) return;

                // Use transaction to ensure atomic updates
                try {
                    await db.runTransaction(async (transaction) => {
                        const currentDoc = await transaction.get(gameRef);
                        if (!currentDoc.exists) return;
                        
                        const currentData = currentDoc.data();
                        
                        // Create copies of the lists for update
                        let newClickTimes = [...currentData.clickTimes];
                        let newTotalErrors = [...currentData.totalErrors];
                        
                        // Update click time for the current player
                        newClickTimes[playerClickIndex] = clickTimeMs;

                        // Check if all players have clicked
                        const allClicked = newClickTimes.every(time => time !== 0);

                        let update = { clickTimes: newClickTimes };
                        
                        if (allClicked) {
                            // Calculate results and update total errors
                            const targetTimeMs = currentData.targetTimeMs;

                            currentData.playerIds.forEach((id, index) => {
                                const clickTime = newClickTimes[index]; // Use the new click time
                                const dev = clickTime - targetTimeMs; 
                                const absDev = Math.abs(dev);
                                
                                // FIX: Update totalErrors based on the new round's result
                                newTotalErrors[index] = (currentData.totalErrors[index] || 0) + absDev;
                            });
                            
                            update.totalErrors = newTotalErrors;
                            
                            // Check if the match is over
                            if (currentData.round < maxRounds) {
                                update.status = 'ROUND_FINISHED';
                            } else {
                                update.status = 'MATCH_FINISHED';
                            }
                        }

                        update.lastUpdateTime = firebase.firestore.FieldValue.serverTimestamp();
                        transaction.update(gameRef, update);

                    });
                } catch (error) {
                    console.error("Error in transaction/recording click:", error);
                }
            }

            /** Starts the next round/match (P1 only). */
            async function startNextRoundOrMatch(gameData) {
                if (gameData.playerIds[0] !== userId) return; // Only the creator can start
                
                const gameRef = getGameRef();
                let update = {};

                if (gameData.status === 'MATCH_FINISHED') {
                    // Reset the entire match
                    update = {
                        status: 'SETUP', // Return to SETUP to allow new players
                        round: 1,
                        // Reset clickTimes and zero out totalErrors, keep playerIds
                        clickTimes: gameData.playerIds.map(() => 0),
                        totalErrors: gameData.playerIds.map(() => 0),
                        targetTimeMs: 0, // Set to 0 in SETUP mode
                        lastUpdateTime: firebase.firestore.FieldValue.serverTimestamp(),
                    };
                    // FIX: After match finish, we want the creator to be able to remove old players, but for simplicity, we keep them.
                } else if (gameData.status === 'ROUND_FINISHED' || gameData.status === 'SETUP') { 
                    // FIX: Allow start from SETUP and ROUND_FINISHED
                    // Start the next round (or round 1)
                    const isSetup = gameData.status === 'SETUP';
                    const nextRound = isSetup ? 1 : gameData.round + 1;

                    update = {
                        status: 'WAITING_FOR_CLICKS',
                        round: nextRound,
                        // Reset clickTimes, keep totalErrors
                        clickTimes: gameData.playerIds.map(() => 0),
                        targetTimeMs: generateRandomTime(),
                        lastUpdateTime: firebase.firestore.FieldValue.serverTimestamp(),
                    };
                }

                try {
                    await gameRef.update(update);
                } catch (error) {
                    console.error("Error starting next round/match:", error);
                }
            }

            /** Resets only gameId locally. Used when starting a new game/round. */
            function resetGameId() {
                if (unsubscribe) unsubscribe();
                gameId = null;
                playerRole = null;
                playerIndex = -1;
                // Re-activate the listener for available games in setup mode
                listenForAvailableGames(); 
                document.getElementById('available-games-area').classList.remove('hidden');

            }

            /** Resets the application to the initial state. */
            function resetLocalState() {
                if (unsubscribeAvailableGames) unsubscribeAvailableGames();
                resetGameId();
                sessionStorage.removeItem('gameStartTime');
                
                // FIX: Force show gameControlArea here
                gameControlArea.classList.remove('hidden'); 
                mainGameArea.classList.add('hidden'); // Hide game view
                
                document.getElementById('app-title').classList.remove('hidden');
                document.getElementById('app-description').classList.remove('hidden');
                
                // Reset UI to default state
                totalScoreboard.innerHTML = '<p class="text-xs text-gray-400">Results shown after match finish.</p>';
                availableGamesList.innerHTML = '<p class="text-xs text-gray-400">Fetching...</p>';
                startSetupButton.disabled = false;
                
                // NOTE: initApp is called via window.onload, so we don't need to call it here.
            }

            // --- EVENT LISTENERS ---

            document.addEventListener('DOMContentLoaded', function() {
                try {
                    
                    // Steg 1: Initialize all global DOM references.
                    initializeAppComponents();
                    
                    // Steg 2: All event listeners are now defined in initializeAppComponents()
                    
                    // Steg 3: Start the Firebase process.
                    // initApp() is called inside initializeAppComponents()

                } catch (e) {
                    // Let the crash in the initialization be logged, but don't prevent the rest of the page
                    console.error("Initialization failed in main script block:", e);
                    authStatus.textContent = `CRITICAL ERROR ON STARTUP: ${e.message || 'Unknown error during execution.'}`;
                }

            });
            
            // The global onload function runs when everything is loaded
            window.onload = function() {
                initApp();
            };

        </script>
    </body>
    </html>
